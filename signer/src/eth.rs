// Copyright 2019-2023 Parity Technologies (UK) Ltd.
// This file is dual-licensed as Apache-2.0 or GPL-3.0.
// see LICENSE for license details.

//! An ethereum signer implementation.
use derive_more::{Display, From};
use hex::FromHex;
use keccak_hash::keccak;
use secp256k1::{Keypair, Message, Secp256k1, SecretKey};

/// An ethereum signer implementation.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct EthereumSigner(Keypair);

impl From<crate::ecdsa::Keypair> for EthereumSigner {
    fn from(kp: crate::ecdsa::Keypair) -> Self {
        EthereumSigner(kp.0)
    }
}

impl EthereumSigner {
    /// Construct an ethereum signer from a hex-encoded private key.
    pub fn from_private_key_hex(hex: &str) -> Result<EthereumSigner, Error> {
        let seed = <[u8; 32]>::from_hex(hex).map_err(Error::Hex)?;
        let secret = SecretKey::from_slice(&seed).map_err(|_| Error::InvalidPrivateKey)?;
        Ok(EthereumSigner(secp256k1::Keypair::from_secret_key(
            &Secp256k1::signing_only(),
            &secret,
        )))
    }

    /// Obtain the [`secp256k1::PublicKey`] of this signer.
    pub fn public_key(&self) -> secp256k1::PublicKey {
        self.0.public_key()
    }

    /// Obtains the public address of the account by taking the last 20 bytes
    /// of the Keccak-256 hash of the public key.
    pub fn account_id(&self) -> AccountId20 {
        let uncompressed = self.0.public_key().serialize_uncompressed();
        let hash = keccak(&uncompressed[1..]).0;
        let hash20 = hash[12..].try_into().expect("should be 20 bytes");
        AccountId20(hash20)
    }

    /// Sign any arbitrary message.
    pub fn sign(&self, signer_payload: &[u8]) -> EthereumSignature {
        let message_hash = keccak(signer_payload);
        let wrapped =
            Message::from_digest_slice(message_hash.as_bytes()).expect("Message is 32 bytes; qed");
        EthereumSignature(crate::ecdsa::sign(&self.0.secret_key(), &wrapped))
    }
}

/// A signature generated by [`EthereumSigner::sign()`].
#[derive(Debug, Clone, Copy, PartialEq, Eq, codec::Encode)]
pub struct EthereumSignature(pub [u8; 65]);

impl AsRef<[u8; 65]> for EthereumSignature {
    fn as_ref(&self) -> &[u8; 65] {
        &self.0
    }
}

/// A 20-byte cryptographic identifier.
#[derive(Debug, Copy, Clone, PartialEq, Eq, codec::Encode)]
pub struct AccountId20(pub [u8; 20]);

impl AsRef<[u8]> for AccountId20 {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

/// Verify that some signature for a message was created by the owner of the [`secp256k1::PublicKey`].
///
/// ```rust
/// use subxt_signer::eth;
///
/// let signer = eth::dev::alice();
/// let message = b"Hello!";
///
/// let signature = signer.sign(message);
/// let public_key = signer.public_key();
/// assert!(eth::verify(&signature, message, &public_key));
/// ```
pub fn verify<M: AsRef<[u8]>>(
    sig: &EthereumSignature,
    message: M,
    pub_key: &secp256k1::PublicKey,
) -> bool {
    let Ok(signature) = secp256k1::ecdsa::Signature::from_compact(&sig.0[..64]) else {
        return false;
    };
    let message_hash = keccak(message.as_ref());
    let wrapped =
        Message::from_digest_slice(message_hash.as_bytes()).expect("Message is 32 bytes; qed");

    Secp256k1::verification_only()
        .verify_ecdsa(&wrapped, &signature, pub_key)
        .is_ok()
}

/// An error handed back if creating the ethereum signer fails.
#[derive(Debug, PartialEq, Display, From)]
pub enum Error {
    /// Invalid private key.
    #[display(fmt = "Invalid private key")]
    #[from(ignore)]
    InvalidPrivateKey,
    /// Invalid hex.
    #[display(fmt = "Cannot parse hex string: {_0}")]
    Hex(hex::FromHexError),
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

/// Dev accounts, helpful for testing but not to be used in production,
/// since the secret keys are known.
pub mod dev {
    use super::*;
    use crate::ecdsa::dev;

    once_static_cloned! {
        /// Equivalent to `{DEV_PHRASE}//Alice`.
        pub fn alice() -> EthereumSigner {
            dev::alice().into()
        }
        /// Equivalent to `{DEV_PHRASE}//Bob`.
        pub fn bob() -> EthereumSigner {
            dev::bob().into()
        }
        /// Equivalent to `{DEV_PHRASE}//Charlie`.
        pub fn charlie() -> EthereumSigner {
            dev::charlie().into()
        }
        /// Equivalent to `{DEV_PHRASE}//Dave`.
        pub fn dave() -> EthereumSigner {
            dev::dave().into()
        }
        /// Equivalent to `{DEV_PHRASE}//Eve`.
        pub fn eve() -> EthereumSigner {
            dev::eve().into()
        }
        /// Equivalent to `{DEV_PHRASE}//Ferdie`.
        pub fn ferdie() -> EthereumSigner {
            dev::ferdie().into()
        }
        /// Equivalent to `{DEV_PHRASE}//One`.
        pub fn one() -> EthereumSigner {
            dev::one().into()
        }
        /// Equivalent to `{DEV_PHRASE}//Two`.
        pub fn two() -> EthereumSigner {
            dev::two().into()
        }
    }
}

#[cfg(feature = "subxt")]
mod subxt_compat {
    use super::*;

    impl<T: subxt::Config> subxt::tx::Signer<T> for EthereumSigner
    where
        T::AccountId: From<AccountId20>,
        T::Address: From<AccountId20>,
        T::Signature: From<EthereumSignature>,
    {
        fn account_id(&self) -> T::AccountId {
            self.account_id().into()
        }

        fn address(&self) -> T::Address {
            self.account_id().into()
        }

        fn sign(&self, signer_payload: &[u8]) -> T::Signature {
            self.sign(signer_payload).into()
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use proptest::prelude::*;

    use hex::ToHex;

    enum StubEthRuntimeConfig {}

    impl subxt::Config for StubEthRuntimeConfig {
        type Hash = subxt::utils::H256;
        type AccountId = super::AccountId20;
        type Address = super::AccountId20;
        type Signature = super::EthereumSignature;
        type Hasher = subxt::config::substrate::BlakeTwo256;
        type Header =
            subxt::config::substrate::SubstrateHeader<u32, subxt::config::substrate::BlakeTwo256>;
        type ExtrinsicParams = subxt::config::SubstrateExtrinsicParams<Self>;
        type AssetId = u32;
    }

    type Signer = dyn subxt::tx::Signer<StubEthRuntimeConfig>;

    prop_compose! {
        fn keypair()(seed in any::<[u8; 32]>()) -> secp256k1::Keypair {
            let secret = SecretKey::from_slice(&seed).expect("valid secret key");
           secp256k1::Keypair::from_secret_key(
                &Secp256k1::new(),
                &secret,
            )
        }
    }

    proptest! {
        #[test]
        fn check_subxt_signer_implementation_matches(keypair in keypair(), msg in ".*") {
            let eth_signer = EthereumSigner(keypair);
            let msg_as_bytes = msg.as_bytes();

            assert_eq!(Signer::account_id(&eth_signer), eth_signer.account_id());
            assert_eq!(Signer::sign(&eth_signer, msg_as_bytes), eth_signer.sign(msg_as_bytes));
        }

        #[test]
        fn check_account_id(keypair in keypair()) {
            let account_id = {
                let uncompressed = keypair.public_key().serialize_uncompressed();
                let hash = keccak(&uncompressed[1..]).0;
                let hash20 = hash[12..].try_into().expect("should be 20 bytes");
                AccountId20(hash20)
            };
            let eth_signer = EthereumSigner(keypair);

            assert_eq!(eth_signer.account_id(), account_id);

        }

        #[test]
        fn check_account_id_eq_address(keypair in keypair()) {
            let eth_signer = EthereumSigner(keypair);
            assert_eq!(Signer::account_id(&eth_signer), Signer::address(&eth_signer));
        }

        #[test]
        fn check_from_private_key_hex_matches(keypair in keypair()) {
            let private_key = keypair.secret_key();
            let private_key_hex = private_key.as_ref().encode_hex::<String>();
            let eth_signer = EthereumSigner::from_private_key_hex(&private_key_hex)
                .expect("valid private key");
            assert_eq!(eth_signer, EthereumSigner(keypair));
        }

        #[test]
        fn check_signing_and_verifying_matches(keypair in keypair(), msg in ".*") {
            let eth_signer = EthereumSigner(keypair);
            let sig = Signer::sign(&eth_signer, msg.as_bytes());

            assert!(verify(
                &sig,
                msg,
                &eth_signer.public_key())
            );
        }
    }
}
